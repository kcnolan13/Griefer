<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>spr_weapon_generic</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///DEFINITIONS
depth = -12
netvars = ds_map_create()

myFlash = noone
noflash_counter = 0
bounces = 0

//dummy vars
counter = 0
exclude_bots = false

was_active = false
reached_hitscan = false
max_charge_counter = 0
mi_jugador = NO_HANDLE
dat_jugador = NO_HANDLE

destroyed = false

varWrite("sound_reload",snd_reload0)

//bot weapon selection
varWrite("lethality",0)
varWrite("range_rating",64*8)
varWrite("range_trump",false)
varWrite("range_trump_distance",64*8)
varWrite("range_trump_extra_lethality",0)

//graphics
myCursor = cursor_pistol
varWrite("visible",false)
varWrite("name","Snub Pistol")
varWrite("sprite",spr_pistol)           //in-game weapon image
varWrite("icon",spr_pistol)             //GUI weapon image
varWrite("bullet_icon",icon_bullet)     //GUI shell icon
varWrite("muzzle_offset",70)            //how far away to spawn bullets
varWrite("pose","pistol")               //arm pose to use
varWrite("scale",1)                     //prescale weapon size
varWrite("flash",flash_pistol)          //muzzle flash object

//trajectories
varWrite("draw_trajectory",false)
varWrite("traj_gravity",2)        //projectile gravity
varWrite("traj_rigidity",3)       //projectile rigidity
varWrite("traj_color",c_white)    //trajectory main color
varWrite("traj_width",2)          //width of main segments
varWrite("traj_resolution",16)    //pixels per line segment
varWrite("traj_length",64*8)      //trajectory length
varWrite("traj_alpha1",1)         //starting alpha
varWrite("traj_alpha2",1)         //alpha in middle
varWrite("traj_alpha3",0)         //alpha at end
varWrite("traj_highlight",spr_tossable_generic) //trajectory highlight sprite
//varWrite("traj_highlight_color",c_white)
varWrite("traj_highlight_interval",64*1) //distance between highlights
varWrite("traj_flag",FL_BOUNCE)

//specs
varWrite("clip_cap",12)                 //clip capacity
varWrite("clip",varRead("clip_cap"))
varWrite("starting_ammo",3*varRead("clip_cap"))
varWrite("max_ammo",5*varRead("clip_cap"))
varWrite("ammo",varRead("starting_ammo"))
varWrite("clip_decrement",1)            //how much to subtract with each trigger pull
varWrite("reload_time",1*30)
varWrite("charge_delay",30)     //length of time to full charge
varWrite("charge_weight",2)             //charge % = ((charge_delay-charge_counter)+charge_delay*charge_weight)/(1+charge_weight)
varWrite("charge_counter",-1)
varWrite("charge",0)                    //charge % --&gt; 0 to 1
varWrite("charge_offset",0.25)          //initial charge so it doesnt drop at your feet --&gt; 0 to 1
varWrite("discharge_delay_max",4)       //time after mouse release when nade is thrown
varWrite("discharge_delay",-1)
varWrite("quicktoss_charge",0.75)       //charge % for quicktoss
varWrite("quicktoss_discharge_delay_max",4) //frames before quicktoss actually occurs

//shooting mechanics
varWrite("view_scale",1)               //view scale multiplier
varWrite("kick",10)                     //visual arm recoil
varWrite("bullet",bullet_pistol)        //bullet object
varWrite("bullet_speed",50)             
varWrite("cant_shoot_max",3)            //delay after shooting
varWrite("cant_shoot_max_original",3)
varWrite("spread_count",1)              //num bullets to fire         
varWrite("spread_swath",0)              //angular spreadshot swath
varWrite("spread_spawn_translation",16) //bullet x-y spawn range around muzzle
varWrite("inaccuracy",0)                //random angle added to bullets
varWrite("recoil",5)                    //increments inaccuracy with each shot
varWrite("handling",1.25)               //how fast inaccuracy goes down
varWrite("view_shake_duration","short") //short, medium, long
varWrite("view_shake",5)

//engine
time_since_shot = 0
varWrite("cant_shoot",false)
varWrite("active",false)                //true when in-use by local player
varWrite("is_nade",false)
varWrite("is_secondary",false)
varWrite("my_player",MY_PLAYER_NULL)                //uniqueId of bonded player
varWrite("control_type","left_press")   //fire button left_press, left_hold, or left_charge
varWrite("can_disappear",true)          //disappear from the battlefield after a while
varWrite("disappear_counter",-1)         
varWrite("disappear_delay",60*10)
varWrite("reload_counter",-1)
varWrite("reload_incremental",false)
varWrite("reload_empty_delay",30/2)
varWrite("reload_empty_counter",-1)
varWrite("quicktoss_backcycles",0)
varWrite("quicktoss_time_between",4)
varWrite("quicktoss_timer",0)
varWrite("clip_previous",0)
varWrite("ammo_previous",0)

//dummy var
varWrite("flash_hitscan",flash_hitscan_simple_long)

varWrite("spawner",-1)
varWrite("been_picked_up",false)

sprite_index = spr_weapon_generic
initialize_physics()
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///free net vars

printf("::: destroying weapon "+string(varRead("name"))+", my_player="+string(varRead("my_player")))

if instance_exists(myCursor)
    myCursor.active = false
    
ds_map_destroy(netvars)
destroyed = true
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///fix to player and weapon contemplation
visible = true

if being_held()
{
     varWrite("myX",objVarRead(dat_jugador,"myX"))
     varWrite("myY",objVarRead(dat_jugador,"myY"))
}
else
{
    //PICKUP CONTEMPLATION
    for (var i=0; i&lt;instance_number(player); i++)
    {
        var playa = instance_find(player,i)
        if (is_bot(playa) or playa = myPlayer()) and not being_held()
        {
            if interactable(playa) and playa.weapon_contemplating &lt; 0
            {
                with playa
                {
                    if not find_my_weapon_by_name(objVarRead(other.id,"name"))
                        weapon_contemplating = other.id
                }
            }
            
            //AUTO ABSORPTION
            var players_wep = find_players_weapon_by_name(playa,varRead("name"))
            if players_wep
            {
                if objVarRead(players_wep,"ammo") &lt; objVarRead(players_wep,"max_ammo") and super_interactable(playa) //and net_manager.local_player.weapon_contemplating = id
                {
                    printf("ammo = "+string(objVarRead(players_wep,"ammo"))+" , max_ammo = "+string(objVarRead(players_wep,"max_ammo"))+" , absorbing more!!")
                    with (playa) 
                    {
                        absorb_weapon(other.id)
                        exit //this weapon is now dead --&gt; ds_map has been freed
                    }
                }
            }
            
            if not interactable(playa) and playa.weapon_contemplating = id
            {
                playa.weapon_contemplating = NO_HANDLE
            }
        
        }
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///fix to player
if being_held()
{
     varWrite("myX",objVarRead(dat_jugador,"myX"))
     varWrite("myY",objVarRead(dat_jugador,"myY"))
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///framely weapon controls
if not global.map_editor
    framely_weapon_controls()
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///standard behavior

if mi_jugador = -1 and not being_held()
    mi_jugador = NO_HANDLE

if varRead("active")
    was_active = true

if instance_exists(myCursor) and ((instance_exists(dat_jugador) and not is_bot(dat_jugador)) or not instance_exists(dat_jugador))
{
    if varRead("active")
    {
        myCursor.active = true
        myCursor.inaccuracy = varRead("inaccuracy")
    }
    else if was_active
    {
        was_active = false
        myCursor.active = false
    }
} else if instance_exists(dat_jugador) and not is_bot(dat_jugador) 
    printf("ERROR: nonexistant cursor for: "+varRead("name"))

if object_index = weapon_vulcan
{
    time_since_shot++
    if time_since_shot &gt; 30 and varRead("cant_shoot_max") &lt; varRead("cant_shoot_max_original")
    {
        varAdd("cant_shoot_max",1)
    }
}

//UNIVERSAL BEHAVIOR
if varRead("draw_trajectory")
    visible = true

//unbond from contemplation slot if picked up by someone else
if lobby_leader()
{
    if net_manager.local_player.weapon_contemplating = id
        net_manager.local_player.weapon_contemplating = NO_HANDLE
}

if being_held()
{
     varWrite("myX",objVarRead(dat_jugador,"myX"))
     varWrite("myY",objVarRead(dat_jugador,"myY"))
     varWrite("visible",false)
} 
else 
{
    //bail on reloading
    bail_on_reloading()
    
    //bail on charging
    bail_on_charging()

    varWrite("visible",true)
    image_xscale = PLAYER_SCALE*varRead("scale")
    image_yscale = PLAYER_SCALE*varRead("scale")
    
    //only apply physics if this weapon has been dropped by a player
    if varRead("been_picked_up")
        scr_basic_physics()
    
    if varRead("can_disappear") and varRead("disappear_counter") &gt; 0
    {
        //DISAPPEAR EMPTY WEAPONS --&gt; ONLY PLAYER 0 IS ALLOWED TO DO THIS
        varSub("disappear_counter",1)
        if varRead("disappear_counter") = 0 and lobby_leader()
        {
            printf("::: disappearing weapon: "+string(varRead("uniqueId"))+" : "+varRead("name"))
            instance_destroy_for_everyone(id)
            exit
        }
    }
    
    //DESTROY EMPTY WEAPONS --&gt; ONLY PLAYER 0 IS ALLOWED TO DO THIS
    if varRead("ammo") &lt; 1 and varRead("clip") &lt; 1
    {
        if lobby_leader()
        {
            printf("::: destroying empty weapon: "+string(string(varRead("uniqueId")))+" : "+varRead("name"))
            instance_destroy_for_everyone(id)
            exit
        }
        else
        {
            printf("::: "+varRead("name")+" is empty, but not lobby_leader() so can't destroy it")   
        }
    }
}

//sync up real vars with net vars
//visible = varRead("visible")
x = varRead("myX")
y = varRead("myY")

//inaccuracy and handling
if varRead("inaccuracy") &gt; 0
{
    var temp = div_real(varRead("inaccuracy"),varRead("handling"))
    if temp &lt; 0.25
        varWrite("inaccuracy",0)
    else
        varWrite("inaccuracy",temp)
}

//LOCAL BEHAVIOR
    if varRead("active")
    {
    
        if object_index = weapon_torque
        {
            if varRead("charge") = 1
            {
                reached_hitscan = true
                varWrite("bullet_speed",1000)
                max_charge_counter++
                
                if max_charge_counter &gt; varRead("max_charge_time")
                {
                    weapon_discharge()
                }
                
            } else 
            {
                reached_hitscan = false
                varWrite("bullet_speed",62)
                max_charge_counter = 0
            }
        }
    
        if varRead("charge") &gt; 0 and not varRead("quicktoss_backcycles") and not is_bot(dat_jugador)
        {
            //draw projectile trajectory
            varWrite("draw_trajectory",true)
        }
        
        if not varRead("charge") &gt; 0 or is_bot(dat_jugador)
        {
            varWrite("draw_trajectory",false)
            
            if match_ending() and torque_charging() 
            {
                weapon_release_left()
            }
        }
    
        if varRead("quicktoss_timer")
        {
            varSub("quicktoss_timer",real_speed(1))
            if varRead("quicktoss_timer") &lt; 1
                varWrite("quicktoss_timer",0)
        }
    
        if varRead("is_nade")
        {
            objVarWrite(dat_jugador,"nades",varRead("clip"))
            obj_update_real(dat_jugador,"nades",FL_NORMAL)
        }
    
        if varRead("discharge_delay") &gt; 0
        {
            //discharging in a few frames....
            varSub("discharge_delay",1)
            if varRead("discharge_delay") &lt; 1
            {
                weapon_discharge()
            }
        }
    
        if varRead("cant_shoot")
            varSub("cant_shoot",real_speed(1))
        
        if varRead("cant_shoot") &lt; 0
            varWrite("cant_shoot",0)
            
        //trigger a reload if empty (and enough time has passed)
        if varRead("clip") &lt; varRead("clip_decrement") and varRead("ammo") &gt; 0 and varRead("reload_counter") &lt; 0
        {
            if varRead("reload_empty_counter") &lt; 0
            {
                varWrite("reload_empty_counter",varRead("reload_empty_delay"))
            } else {
                varWrite("reload_empty_counter",sub_real(varRead("reload_empty_counter"),1))
                if not varRead("reload_empty_counter")
                {
                    //trigger the reload
                    trigger_reload()
                }
            }
        } else {
            varWrite("reload_empty_counter",-1)
        }
            
        if varRead("reload_counter") &gt; 0
        {
            //printf("::: sub_real(varRead('reload_counter'),1) = "+string(sub_real(varRead("reload_counter"),1)))
            varWrite("reload_counter",sub_real(varRead("reload_counter"),1))
            if varRead("reload_incremental")
            {
                if (varRead("reload_time") - varRead("reload_counter") &gt; (varRead("reload_time")/varRead("clip_cap"))*(1+varRead("clip")))
                {
                    //take a bullet from ammo and add to clip
                    if varRead("ammo") &gt; 0 and varRead("clip") &lt; varRead("clip_cap")
                    {
                        varAdd("clip",1)
                        varSub("ammo",1)
                        
                        audio(snd_reload_shell,1)
                        
                        //stop reloading at this point if no more ammo
                        if varRead("ammo") = 0
                        {
                            varWrite("reload_counter",-1)
                        }
                    }
                }
            }
            
            //FULL RELOAD WHEN READY
            if varRead("reload_counter") = 0
            {
                reload_full()
            }
        }
            
        //SEND NETWORK VARS
        if varRead("ammo_previous") != varRead("ammo") or varRead("clip_previous") != varRead("clip")
        {
            pkgCreate()
                obj_update_real(id,"clip",0)
                obj_update_real(id,"ammo",0)
                
                varWrite("ammo_previous",varRead("ammo"))
                varWrite("clip_previous",varRead("clip"))
                obj_update_real(id,"clip_previous",0)
                obj_update_real(id,"ammo_previous",0)
            pkgSend()
        }
        
    } else {
        //bail on reloading()
        bail_on_reloading()
        //bail on charging
        bail_on_charging()
    }
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///draw code + trajectories
if !instance_exists(id) exit

if string(varRead("my_player")) = MY_PLAYER_NULL
    draw_sprite_ext(varRead("sprite"),image_index,x,y,image_xscale*WEAPON_SCALE,image_xscale*WEAPON_SCALE,image_angle,image_blend,image_alpha)
    
if not is_string(varRead("my_player"))
{
    printf("WARNING: draw ev weapon_generic: my_player not a string val: "+string(varRead("my_player")))    
}
    
if /*match_starting() or */ match_ending() exit

/*else if varRead("active")
    {
        temp_playah = find_player(varRead("my_player"))
        draw_set_color(c_white)
        draw_set_alpha(1)
        draw_text(x,y-100,objVarRead(temp_playah,"pName"))
    }*/

//trajectories

if not varRead("active") or not varRead("draw_trajectory")
{
    return false
}

//DRAW THE TRAJECTORY
var dir = point_direction(x,y,cursor.x,cursor.y)
var xi = x+trigx(varRead("muzzle_offset"),dir)
var yi = y+trigy(varRead("muzzle_offset"),dir)

if varRead("is_nade") or varRead("charge") &gt; 0
    var spd = varRead("charge")*varRead("bullet_speed")
else
    var spd = varRead("bullet_speed")
    
var grav = varRead("traj_gravity")

if object_index = weapon_torque and varRead("charge") = 1
{
    spd = 20
    grav = 0
}

var rigidity = varRead("traj_rigidity")
var color = varRead("traj_color")
var width = varRead("traj_width")
var resolution = varRead("traj_resolution")
var length = varRead("traj_length")
var highlight = varRead("traj_highlight")
var highlight_interval = varRead("traj_highlight_interval")
var alpha1 = varRead("traj_alpha1")
var alpha2 = varRead("traj_alpha2")
var alpha3 = varRead("traj_alpha3")
var flag = varRead("traj_flag")

draw_trajectory(xi, yi, spd, dir, grav, rigidity, color, width, resolution, length, highlight, highlight_interval, alpha1, alpha2, alpha3, flag)
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>20,33</point>
    <point>30,30</point>
  </PhysicsShapePoints>
</object>
